/* MVC style coding for a dynamic presentation of bouldering results
* Copyright 2011, Tim Hatch
* Dual licensed under the MIT or GPL Version 2 licenses.
*/

/***********************************
*
*	CODEKIT DECLARATIONS
*
***********************************/
/*global _        */

/***********************************
 *
 * UNDERSCORE UTILITIES
 *
 ***********************************/

/*
 * Use Mustache-style for Underscore templates
 *
 */
_.templateSettings = {
	evaluate	: /\{\[([\s\S]+?)\]\}/g,
	interpolate	: /\{\{([\s\S]+?)\}\}/g
};

/*
 * Underscore mixins for the results display classes
 *
 */
_.mixin({
	/*
	* compareElements(arr, a, b)
	*
	* An underscore mixin function to perform a deep compare on two elements of an 2D numeric array.
	* returns +1 if the first sub-array is 'greater'; -1 if the first sub-array is 'smaller'; and 0 if the two sub-arrays are identical
	* the comparison is performed by comparing each element of the two sub-arrays in turn
	*
	*/
	compareElements: function(arr, a, b){
		var depth = 0
		while (depth < arr[a].length && depth < arr[b].length) {
			if (arr[a][depth] < arr[b][depth]) { return 1 }
			if (arr[a][depth] > arr[b][depth]) { return -1 }
			depth++
		}
		return 0
	},

	/*
	* quicksort(arr, left, right)
	*
	* An underscore mixin function implementing a modified quicksort algorithm (the pivot is set as the first element of each comparison,
	* rather than set randomly or mid-way)
	* Based on the C++ implementation referenced at:
	* http://www.algolist.net/Algorithms/Sorting/Quicksort
	* and the javascript implementation at:
	* http://www.webxpertz.net/forums/showthread.php/11030-Article-JavaScript-Sorting-a-Multidimensional-Array-â€”-quicksort
	* The main change is to set the pivot as the left edge of the partition being tested (as opposed to the mid point or some random element)
	*
	*/
	quicksort: function(arr, left, right){
		var i = left, j = right, pivot = left, tmp
		/* partition */
		while (i <= j) {
			while (_.compareElements(arr, i, pivot) > 0 ) i++  // Use a bespoke compare()
			while (_.compareElements(arr, j, pivot) < 0 ) j--
			if (i <= j) {
				tmp    = arr[i]
				arr[i] = arr[j]
				arr[j] = tmp
				i++
				j--
			}
		}
		/* recursion*/
		if (left < j )	_.quicksort(arr, left, j )
		if (i < right)	_.quicksort(arr, i, right)
	},

	/*
	* titleize(str), strRight(str, sep)
	*
	* Underscore mixins to either 'titleize' a string or create a substring from the right hand part of an existing string
	* Taken from the underscore string manipulation extensions at:
	* https://github.com/epeli/underscore.string
	*
	*/
	titleize: function(str){
		if (str == null) return ''
		return String(str).replace(/(?:^|\s)\S/g, function(c){ return c.toUpperCase() })
	},
	strRight: function(str, sep){
		if (str == null) return ''
		str = String(str); sep = sep != null ? String(sep) : sep
		var pos = !sep ? -1 : str.indexOf(sep)
		return ~pos ? str.slice(pos+sep.length, str.length) : str
	}
})

/* **********************************************
     Begin THClimber.js
********************************************** */

/* MVC style coding for a dynamic presentation of bouldering results
* Copyright 2011, Tim Hatch
* Dual licensed under the MIT or GPL Version 2 licenses.
*/

/***********************************
*
*	CODEKIT DECLARATIONS
*
***********************************/
/*global Backbone */
/*global _        */
/*global App      */

window.App = window.App || {}

/***********************************
*
* MODELS
*
***********************************/

/*
*	Climber model extending Backbone.js 'Model' class
*/
App.Climber = Backbone.Model.extend({
	/*
	* Properties used from eGroupware JSON Interface
	* (str)start_order, (str)PerId								-> init & set by collection::load()
	* (str)lastname, (str)nation (str)rank_prev_heat			-> init & set by collection::load()
	*
	* Computed Properties
	*/

	/* getResults()
	* Return the top/bonus data as an array for sorting
	*/
	getResults: function(){
		var arr = [];
		arr[0] = -this.attributes.points				// negative data gives a descending sort
		arr[1] = -this.attributes.bonus					// positive data an ascending sort
		arr[2] = -this.attributes.id
		return arr;
	}
});

/***********************************
*
*	VIEWS
*
***********************************/

/*
* Climber view extending Backbone.js 'View' class
*/
App.ClimberView = Backbone.View.extend({
	tagName				: 'li',
//	className			: 'not_list',
	events				: {
//		'click .cbox' : 'toggleFav'
	},

	/*
	* initialize(): Trigger the view's update method if the associated model is changed
	* NOTE: The association between model & view is made in the superview's initialize method
	*
	*/
	initialize: function(){
		// Bind the ::update function to any change in the related model.
		this.listenTo(this.model, 'change', this.update, this)
	},

	/*
	*	render(): Render a view with 5 results blocks when the associated model is first loaded.
	*	The underscore _.template method is used to interpret the actual template (in the DOM) and will layout 5 sub-elements to show results on each bloc.
	*
	*	Pass in the EGW Category for the relevant model
	*
	*/
	render: function(){

		// Render the underscore template
		var tmpl= $('#climber_template').text(),
			str	= _.template(tmpl, {
			rank	: this.model.get('currentranking') || 1,
			name	: _.titleize(this.model.get('name')),
			code	: this.model.get('category').toUpperCase(),
			points	: this.model.get('points'),
			bonus	: this.model.get('bonus')
		});

		this.$el.html(str);

		// Add a class to denote the category (used by $.isotope for filtering)
		this.$('.rank').addClass(this.model.get('category'))

		// Set the data::rankorder property so that we can sort the superview when it is rendered
		this.$el.data('rankorder', this.model.get('rankorder'))

		// Return
		return this;
	},

	/*
	*	update(): Update the view when the associated model is updated
	*
	*/
	update: function(){


//		var syntheticRank = this.model.get('points')+(this.model.get('bonus')/100)
		var syntheticRank = parseInt(100*this.model.get('points'), 10) + parseInt(this.model.get('bonus'),10)
		this.$el.data('rankorder', -syntheticRank)

		// Update the displayed rank & the rankorder data element used by the isotope sort function
		this.$('.rank').text(this.model.get('currentranking'))

		// Update the aggegrate results
		this.$('.pts').text(this.model.get('points'))
		this.$('.bns').text(this.model.get('bonus'))
//		return this;
	}
});

/* **********************************************
     Begin THResultsList.js
********************************************** */

/*	MVC style coding for a dynamic presentation of bouldering results
*	Copyright 2011, Tim Hatch
*	Dual licensed under the MIT or GPL Version 2 licenses.
*/

/***********************************
*
*	CODEKIT DECLARATIONS
*
***********************************/
/*global Backbone */
/*global _        */
/*global App      */

window.App = window.App || {}

/***********************************
*
*	MODELS / COLLECTIONS
*
***********************************/

/*
*	ResultsList extending Backbone.js 'Collection' class
*
*/
App.ResultsList = Backbone.Collection.extend({
	url				: './scripts/getJSON.php',
	model			: App.Climber,

	/*
	* initialize()
	*
	* NOTE: Mandatory input parameter is a reference to the application settings model (options.settings)
	* NOTE: Optional input parameters are the round and category for display
	*
	*/
	initialize: function(options){

		// Use the options data to set the round/category if provided, and set the comp & numberofblocs based on the application settings
		this.cat			= options.cat	|| 'm'

	},

	/*
	* loadResults(): Get startlist data from the server
	*
	* Return a bespoke $.deferred instead of simply passing through the $.deferred returned by the $.getJSON call.
	* This allows us to work around the possibility that $.getJSON may return a 404 if (for example) one of the specified Starting Groups does not exist.
	*
	*/
	loadResults: function() {
		var url  = this.url+'?cat='+this.cat,
			$rsp = $.Deferred(),
			$xhr = $.getJSON(url),
			self = this

		$xhr.success(function(data){
			self.parseJSONData(data)				// Tidy up the retrieved eGroupware JSON object
			self.reset(data)						// Create a set of models from the edited 'participants' object
//			window.console.log(data)
			$rsp.resolve(true)						// Resolve the Deferred and pass true for a successful query
		})
		$xhr.error(function(){
			$rsp.resolve(false)						// Resolve the Deferred and pass false for an unsuccessful query
		})
		return $rsp
	},

	/*
	* update(): Get startlist data from the server
	*
	* Uses the same methodology as loadResults() to get around $.getJSON returning a $.deferred with fail status
	*
	*/
	update: function(){
		var url  = this.url+'?cat='+this.cat,
			$rsp = $.Deferred(),
			$xhr = $.getJSON(url),
			self = this

		$xhr.success(function(data){
//			window.console.log(data)
			self.setResults(data)					// Calculate and set the results data for each climber (model)
			self.sort()								// Calculate the resulting rank
			$rsp.resolve(true)
		})
		$xhr.error(function(){
			$rsp.resolve(false)
		})
		return $rsp
	},

	/*
	* parseJSONData(participants): Parse the JSON data returned in loadResults()
	*
	*/
	parseJSONData: function(data) {
		// For each entry in the .participants object
		_(data).each(function(person){
			person.id			= parseInt(person.startnumber, 10)
			person.rankorder	= person.id
		}, this)
	},

	setResults: function(data) {
		var model
		_(data).each(function(person){
//			window.console.log(person.startnumber)
			model = this.get(person.startnumber)
			model.set({ 'points' : person.points, 'bonus' : person.bonus })
		}, this)
	},
	/*
	* sort(): Extract a numeric result from the string provided by eGroupware
	*
	*/
	sort: function(){
//		window.console.log('ResultsList::sort fired')
		var rankArray		= [],
			sortingArray	= [],
			s_len			= this.models.length,
			cr,
			k

		// Push data into a temporary array that we can sort (sortingArray)
		_(this.models).each(function(model){ sortingArray.push(model.getResults()) })

//		window.console.log(sortingArray)
		// Sort by T/TA/B/BA/rank_prev_heat/PerID (this latter gives a 'stable sort' in the event of ==)
		_(sortingArray).quicksort(0, s_len-1)
		// sortingArray.js_quicksort(0, s_len-1)
		// Make a new array containing the 'id' of the climbers in post-sort order
		rankArray = _(sortingArray).map(function(arr){ return -_(arr).last() })
		// Find the climber (model) who is ranked first i.e. the first 'id' contained within rankArray and set their currentranking == 1, and rankorder == 1
		// rankorder is needed for positioning the model view in the DOM and is unique, whereas currentranking may not be unique (if the climber is ex-aequo)
		// This updates the model's currentranking & rankorder attributes
		// NOTE: This structure may be inefficient, as in certain cases a model view will be updated twice - once when the setResults function is called and a second time here if their ranking has also changed. But the problem is that the two are independent...
		this.get(rankArray[0]).set({ 'currentranking' : 1 , 'rankorder' : 1})

		// Now update the ranking and order information for the other climbers...
		// first we need to pop the start_order off the array so that we can correctly test for ex-aequo n T/TA/B/BA/rank_prev_heat
		// Then iterate through the sortingArray... If the result of the climber in rows i and i-1 are the same, make the climber rankings equal. If the two sets of results are different then make the ranking of the climber in row i equal to i+1 (+1 because row indices start at 0 in javascript). The rankorder is however always set at i+1 (this enables a stable visual sort)
		_(sortingArray).each(function(arr){ arr.pop() })
		for(k = 1; k < s_len; k++){
			cr = (_(sortingArray).compareElements(k-1, k) === 0) ? this.get(rankArray[k-1]).get('currentranking') : (k+1)
//			this.get(rankArray[k]).set({ 'currentranking' : cr, 'rankorder' : cr })
			this.get(rankArray[k]).set({ 'currentranking' : cr, 'rankorder' : k+1 })
		}
	}
});



/***********************************
*
*	VIEWS
*
***********************************/

/*!
 * ResultsList view extending Backbone.js 'View' class
 */
App.ResultsListView = Backbone.View.extend({
	$resultsView	: null,
	currentView		: null,
	className		: 'resultslistview',

	/*
	* initialize() : Create the containing view for the collection of individual model views
	* The view is initialized by passing the following options:
	*
	* !Important - The backbone options parameter is used to allow the view to reference the application settings
	*
	*/
	initialize: function(options){

		// Update the view if the favourites button is toggled
//		this.listenTo(this.settings, 'change:ShowFavorites', this.updateView, this)
//		this.listenTo(this.settings, 'change:ShowCategory', this.toggleCategory, this)
	},

	/*
	* loadResults(): Populate the results collections and render the related subviews into the main view
	*
	*/
	loadResults: function(cat){
		var subview,
			$response,
			$deferreds	= [],
			self		= this

		// Pre-render the view container & initialise the collections containing the results
		this.initViewContainer(cat)

		// Fetch results from the server for each collection
		// We return a bespoke $.deferred object from the $.ajax call and create views if that $.deferred returns true
		_(this.resultslists).each(function(collection){
			$response = collection.loadResults()
			$.when($response).done(function(bool){
				// If the collection's loadResults() function returns 'true' (i.e. the collection's getJSON returned data, create and append a subview for each climber)
				if (bool) {
					collection.each(function(model){
						subview =  new App.ClimberView({ model : model })
						self.climberviews.push(subview)
						self.$resultsView.append(subview.render().el)
						// NOTE: Now that we've created the model views, we can update the view to show results
						subview.update()
					})
				}
			})
			$deferreds.push($response)
		})

		// When all $deferreds have completed (i.e. when we have rendered all subviews), initialize $.isotope and call update() to sort/filter the view
		$.when.apply(null, $deferreds).done(function(){

			// Initialise isotope for elements of kind 'li'
			self.$resultsView.isotope({
				itemSelector	: 'li',
				getSortData		: {
					rankorder: function($el){ return parseInt( $el.data('rankorder'), 10) }
				}
			})
			self.updateView()
		})
	},

	/*
	* initViewContainer(): Create the results collections & call the main view render function
	*
	*/
	initViewContainer: function(cat){


		// Create an array of ResultsLists objects (collections) & set up the variables for the first object to be fetched
		this.resultslists	= []

		// Push two collections onto the array for the selected round, either M+F or both Starting Groups for the selected category in Q
		this.resultslists.push(new App.ResultsList({ 'cat' : cat }))
//		this.resultslists.push(new App.ResultsList({ 'cat' : 'f' }))
		this.resultslists.push(new App.ResultsList({ 'cat' : cat+'j' }))
//		this.resultslists.push(new App.ResultsList({ 'cat' : 'fj' }))

		// Pre-render the view container
		this.render()
	},

	/*
	* render(): Render the view container
	*
	*/
	render: function(){
		var str = '<ul></ul>'

		// Clean up any existing views if render is being called other than the first time
		if (this.currentView) { this.close() }
		this.climberviews	= []

		// Create the shell of the view.
		this.$el.html(str)
		this.$resultsView = this.$('ul')	// Cache the resultslist view

		// Append the view to the DOM
		$('#wrapper').prepend(this.el)

		// Create a reference to the current view
		this.currentView = this
	},

	/*
	*	updateView(): Order the displayed results
	*
	*	Takes an optional parameter to force a refresh of the collection data
	*
	*/
	updateView: function(options){
		var $response,
			$deferreds	= [],
			self		= this

		// If force_refresh == true, then get new results from the server
		options || (options = {})

		if (options.force_refresh) {
			_(this.resultslists).each(function(collection){
				$response = collection.update()
				$deferreds.push($response)
			}, this)
		}

		// But in all cases, apply the $.isotope filters to perform the visual sort
		$.when.apply(null, $deferreds).done(function(){

			// Set the default css properties & set the $.isotope filter based on the current application settings
			var cssProperty = 'visible'

			// If 'ShowFavourites' is tagged, then set the visibility property of any other elements to 'hidden' and then filter
			// This avoids a double paint of the viewport.
//			self.$('.not_list').css('visibility', cssProperty)

			// Call the $.isotope updateSortDate() method on the li elements in the view
			// We need to do this as the parameter 'rankorder' will have changed since $.isotope was initialized
			self.$resultsView.isotope( 'updateSortData', self.$('li'))

			// Call the $.isotope sortBy() method using rankorder as the sorting parameter and apply filters to show the top 'n' and to rotate through the remainder
			self.$resultsView.isotope({ 'sortBy': 'rankorder' })
			self.trigger('application_event:toggleajaxspinner')
		})
	}
});


/* **********************************************
     Begin JSResultsF.js
********************************************** */

/* MVC style coding for a dynamic presentation of bouldering results
* Copyright 2011, Tim Hatch
* Dual licensed under the MIT or GPL Version 2 licenses.
*/

// Wrap eveything in a singleton object
var applicationObject = {

	/*
	 * init() - Initialize the object
	 *
	 *
	 */
	init: function(){
		// Initialise in order the settings model and then each of the application views:
		// 1) settingsView, accessing the application settings and containing the settings model
		// 2) headerView, controlling the application views/models -
		// 3) resultsView, displaying the results
		// Pass the settings model allowing them to (make and) respond to changes within without application level event mediation.
		this.resultsView	= new App.ResultsListView()

		// Deal with Android-specific problems...
	},

	/*
	*	updateResultsView(): Refresh the ResultsListView,
	*
	*/
	updateResultsView: function(){
		window.console.log('update results called')
		this.resultsView.updateView({ 'force_refresh' : true })
	}
}

/*
 *	Initialise the object once the DOM has fully loaded
 *
 */
$(document).ready(function(){
	// Extend Backbone Events to the applicationObject and then initialize the object
	_.extend(applicationObject, Backbone.Events)
	applicationObject.init()

	applicationObject.resultsView.loadResults('f')
//	setInterval(function(){ applicationObject.updateResultsView() }, 5000 );
	setTimeout(function(){ applicationObject.updateResultsView() }, 5000 );

});