
#user  nobody;
worker_processes  1;

#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;

#pid        logs/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    # log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
    #                   '$status $body_bytes_sent "$http_referer" '
    #                   '"$http_user_agent" "$http_x_forwarded_for"';

    # access_log  /Library/Logs/nginx/access.log  main;

    sendfile        on;

    keepalive_timeout  65;

    index index.html index.php;
    
    upstream www-upstream-pool{
        server unix:/tmp/php-fpm.sock;
    }

    #include /etc/nginx/conf.d/*.conf;
    #include /usr/local/etc/nginx/sites-enabled/*.conf; 

    server {
      # listen       80;
      #access_log  logs/host.access.log  main;
      
      # Location for nginx files - other linux distributions may differ
      #
      root   /Users/timhatch/Public/www;
      index  index.html index.htm;
      
      # Make site accessible from http://localhost/ 
      #
      server_name  localhost;
    
      # Default location
      #
      location / {
        try_files $uri @proxy;
        # First attempt to serve request as file, then fall back to the proxy.
      }
    
      # PubSub locations
      # Interactive Timer
      location /timers/reset {
        nchan_pubsub;
        nchan_channel_id timer;
      }
    
      # Results stream A
      location /broadcast/stream {
        nchan_pubsub;
        nchan_channel_id results1;
      }
    
      # Results stream B
      location /broadcast/result {
        nchan_pubsub;
        nchan_channel_id results2;
      }
     
      # Sinatra application
      #
      location @proxy {
        # As hinted by http://phrogz.net/nginx-as-reverse-proxy-cache-for-thin
        # This is one of the better tutorial pages online
        #
        proxy_pass http://app; 
        
        # The minimum definition above is fine when for basic HTTP connections, but whilst it allows
        # the creation of a 'text/event-stream’ connection, for some reason it doesn’t appear to 
        # receive events back.
        #
        # http://stackoverflow.com/questions/13672743/eventsource-server-sent-events-through-nginx
        # recommends adding the following headers which seem to fix the problem (but note also the 
        # upstream comments)
        #
        #proxy_set_header Connection '';
        # proxy_http_version 1.1;
        # chunked_transfer_encoding off;
        # proxy_buffering off;
        # proxy_cache off;
      }
    
      # Error page
      error_page  404              /404.html;
      
      # redirect server error pages to the static page /50x.html
      #
      error_page   500 502 503 504  /50x.html;
      location = /50x.html {
          root   html;
      }
    
    }
    
    # Link to one or multiple instances as appropriate
    upstream app {
      server 127.0.0.1:5000;
      #server 127.0.0.1:5001 
    }
}
