//	MVC style coding for a dynamic presentation of competition results
//	Copyright 2012-14  T J Hatch
//
//	Licensed under the Apache License, Version 2.0 (the "License");
//	you may not use this file except in compliance with the License.
//	You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
//	Unless required by applicable law or agreed to in writing, software
//	distributed under the License is distributed on an "AS IS" BASIS,
//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//	See the License for the specific language governing permissions and
//	limitations under the License.

//	-----------------------------------------------------
//	CODEKIT DECLARATIONS
//	-----------------------------------------------------
/* global _        */
//	-----------------------------------------------------
//	Underscore utlities
//	-----------------------------------------------------
//
// Use Mustache-style for Underscore templates
//
_.templateSettings = {
	evaluate	: /\{\[([\s\S]+?)\]\}/g,
	interpolate	: /\{\{([\s\S]+?)\}\}/g
};

//	-----------------------------------------------------
//	Underscore mixins for the results display classes...
//	-----------------------------------------------------
//
_.mixin({
	//
	//	insertionsort(arr, comparator): An underscore mixin function implementing a basic insertion 
	//	sort algorithm operating on a 2D matrix. A comparator function is passed in from the caller.
	// 	Based on the Javascript implementation referenced at:
	//	http://bateru.com/news/2011/03/code-of-the-day-javascript-insertion-sort/
	//
	insertionsort: function(arr, comparator){
		var l = arr.length, i = -1, j, t;

	    while (l--) {
	        t = arr[++i]
	        j = i
	        while (j-- && comparator(arr[j], t)) { arr[j + 1] = arr[j] }
	        arr[j + 1] = t
	    }
	},

	//
	//	compareElements(arr, a, b): An underscore mixin function to perform a deep compare on two elements of a 2D
	//	numeric array. Returns +1 if the first sub-array is 'greater'; -1 if the first sub-array is 'smaller'; and 0 if
	//	the two sub-arrays are identical the comparison is performed by comparing each element of the two sub-arrays in
	//	turn
	//
	// compareElements: function(arr, a, b){
	// 	var depth = 0
	// 	while (depth < arr[a].length && depth < arr[b].length) {
	// 		if (arr[a][depth] < arr[b][depth]) { return 1 }
	// 		if (arr[a][depth] > arr[b][depth]) { return -1 }
	// 		depth++
	// 	}
	// 	return 0
	// },

	//
	// 	quicksort(arr, left, right): An underscore mixin function implementing a quicksort algorithm with the
	//	pivot set at the mid-way element of the array/sub-array being sorted
	// 	Based on the C++ implementation referenced at:
	// 	www.algolist.net/Algorithms/Sorting/Quicksort
	// 	and the javascript implementation at:
	//	www.webxpertz.net/forums/showthread.php/11030-Article-JavaScript-Sorting-a-Multidimensional-Array-â€”-quicksort
	//
	// quicksort: function(arr, left, right){
	// 	var i = left, j = right, pivot = Math.floor((i+j)/2), tmp
	//
	// 	// partition
	// 	while (i <= j) {
	// 		// Use a bespoke compare()
	// 		while (_.compareElements(arr, i, pivot) > 0 ) i++
	// 		while (_.compareElements(arr, j, pivot) < 0 ) j--
	// 		if (i <= j) {
	// 			tmp    = arr[i]
	// 			arr[i] = arr[j]
	// 			arr[j] = tmp
	// 			i++
	// 			j--
	// 		}
	// 	}
	//
	// 	// recursion
	// 	if (left < j )	_.quicksort(arr, left, j )
	// 	if (i < right)	_.quicksort(arr, i, right)
	// },

	//
	//	insertionsortElements(arr, left, right, comparator): insertion sort some defined (might be 
	//	the whole array if the starting and last indices are passed, or a sub-array of a larger 
	//	array). Derived from the above insertionsort() implementation
	//
	// insertionsortElements: function(arr, left, right, comparator){
	// 	var l = right - left + 1,
	// 		i = left - 1,
	// 		j, t
	//
	// 	// Iterate across the matrix
	// 	while (l--) {
	// 		t = arr[++i]
	// 		j = i
	// 		while(j-- && comparator(arr[j], t) { arr[j+1] = arr[j] }
	// 		arr[j+1] = t
	// 	}
	// },

	//
	// 	hybridquicksort(arr, left, right): An underscore mixin function implementing quicksort for large
	//	arrays/sub-arrays, and insertion sort for small arrays/sub-arrays.
	//
	// 	hybridquicksort: function(arr, left, right, comparator){
	// 	var i = left, j = right, pivot = Math.floor((i+j)/2), tmp
	//
	// 	// If the array is small, then use an insertion sort
	// 	if (right - left < 9) { _.insertionsortElements(arr, left, right, comparator) }
	//
	// 	// Otherwise use a quicksort
	// 	else {
	// 		// partition
	// 		while (i <= j) {
	// 			// Use a bespoke compare()
	// 			while (_.compareElements(arr, i, pivot) > 0 ) i++
	// 			while (_.compareElements(arr, j, pivot) < 0 ) j--
	// 			if (i <= j) {
	// 				tmp    = arr[i]
	// 				arr[i] = arr[j]
	// 				arr[j] = tmp
	// 				i++
	// 				j--
	// 			}
	// 		}
	//
	// 		// recursion
	// 		if (left < j )	_.hybridquicksort(arr, left, j )
	// 		if (i < right)	_.hybridquicksort(arr, i, right)
	// 	}
	// },

	//
	//	titleize(str)
	//	Underscore mixins to either 'titleize' a string. Taken from the underscore string
	//	manipulation extensions at:
	//	https://github.com/epeli/underscore.string
	//
	titleize: function(str){
		if (str == null) return ''
		str  = String(str).toLowerCase()
		return str.replace(/(?:^|\s)\S/g, function(c){ return c.toUpperCase() })
	}
})

//  MVC style coding for a dynamic presentation of competition results
//  Copyright 2012-14  T J Hatch
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

//  -----------------------------------------------------
//  CODEKIT DECLARATIONS
//  -----------------------------------------------------
/* global Modernizr */
/* global Promise	*/
/* global Backbone */
/* global _        */
/* global App      */
//  -----------------------------------------------------
//  SCOPE DECLARATIONS
//  -----------------------------------------------------
var App = App || {}
// As THSettings.js is the first .js file loaded, overload the default Backbone View methods here...
// Backbone.View = Backbone.View.extend(Backbone.NativeViewMixin);

//  -----------------------------------------------------
//  AjaxMixin...
//  -----------------------------------------------------
//
//	Mixin to provide basic AJAX functionality required by appication objects
//
App.AjaxMixin = {
	url : '/results/route',
	//	getJSON(url): Fetch a json response from the server, returning the JSON object within an 
	//	ES6-type Promise
	//	!important: As at 03/07/2014, Safari does not support the XMLHttpRequest.responseType = 
	//	"json" type (Chrome does). As a work-around, either (a) test for the type of the response 
	//	and return it, or call JSON.parse or (b) don't send a responseType and always call 
	//	JSON.parse on the returned string
	getJSON: function(query){
		// Construct the full url and append a timestamp to prevent the results caching
		var url = this.url + query

		// Fetch data from the server and resolve the Promise (or reject the Promise if the XMLHttpRequest fails)
		return new Promise(function(resolve, reject){
			var client  = new XMLHttpRequest(),
				handler = function(){
					if (this.readyState === this.DONE) {
						if (this.status === 200) {
							resolve(JSON.parse(this.response))
						} else { reject(this) }
					}
				}
			// Define and send the XMLHttpRequest
			client.open("GET", url)
			client.onreadystatechange = handler
			// client.responseType       = "json"
			client.setRequestHeader("Accept", "application/json")
			client.send()
		})
	}
}

//  -----------------------------------------------------
//  Settings...
//  -----------------------------------------------------
//
//	Settings model extending the Backbone.js 'Model' class
//	This model persists in localStorage the eGroupWare parameters for the results display and 
//	information about the preferred view state.
//
App.Settings = Backbone.Model.extend({

	// Set up a localStorage container
	localStorage : new Backbone.LocalStorage("app_settings"),

	// Set up default categories
	defaults : {
		Boulders    : [5,null,4,4],
		EGWCategory : {
			// Category codes for International (Senior) competitions
			"B" : { "m" : [6], "f" : [5] },
			"L" : { "m" : [1], "f" : [2] },
			"S" : { "m" : [23], "f" : [24] }
			// Category codes for Test competitions
		  	//"B" : { "m" : [63], "f" : [5] },
		  	//"L" : { "m" : [62], "f" : [2] },
		  	//"S" : { "m" : [64], "f" : [24] }
		}
	},

	//
	//		Properties used to interrogate eGroupware JSON Interface
	//		(str)wet_id == EGWComp, (str)grp_id == EGWCategory, (str)route_order == EGWRound
	//
	//		Computed Properties
	//		ShowCategory:	The last viewed/selected category
	//		ShowFavorites:	Defines whether the default is to show all competitors or a list of 
	//		'favourites'
	//		FavoritesList:	The selected 'favourites'
	//
	initialize: function(attributes, options){
		// As we don't need the list of competitions to hold any kind of modifiable state, we don't 
		// need to save the list of comps to localStorage, so make this a direct property of the 
		// model rather than an attribute Likewise whether the app is mobile or desktop
		this.isFullScreenApp          = options.isFullScreenApp   || false
		this.competitionList          = options.competitionList   || []
		this.requestParameters        = options.requestParameters || { "disciplines" : [], "cat_id" : [] }

		// Fetch the model attributes from localStorage
		this.fetch()

		// eGroupWare parameters:
		this.attributes.EGWComp       = this.attributes.EGWComp  || options.defaultCompetition.wet_id
		this.attributes.EGWRound      = this.attributes.EGWRound || 0

		// display parameters
		this.attributes.FavoritesList = this.attributes.FavoritesList || options.FavoritesList
		// NOTE: Use a comp_type parameter to deal with multiple competition types
		// NOTE: Use a comp_rnds parameter to deal with competitions with different numbers of 
		// rounds
		this.attributes.comp_name     = this.attributes.comp_name || options.defaultCompetition.name
		this.attributes.comp_type     = this.attributes.comp_type || options.defaultCompetition.type
		this.attributes.comp_rnds     = this.attributes.comp_rnds || (options.defaultCompetition.rnds || 3)

		// NOTE: ShowCategory & ShowFavorites are === false by default unless read through fetch()
		// NOTE: Use a ShowAgeGroup parameter to deal with multiple age groups (e.g. Youth 
		// competitions)
		this.attributes.ShowCategory  = this.attributes.ShowCategory  || 0
		this.attributes.ShowFavorites = this.attributes.ShowFavorites || 0
		this.attributes.ShowAgeGroup  = this.attributes.ShowAgeGroup  || 0
	},

	//
	//	fetchEGWCalendarData(): Fetch the competition calendar for the current year and create a 
	//	list of competitions for display
	//
	fetchEGWCalendarData: function(){
		var disps = this.requestParameters.disciplines,
			catID = this.requestParameters.cat_id.toString(),
			year  = new Date(),
			query = '?year=' + year.getFullYear() + '&filter[cat_id]=' + catID,
			self  = this, parse = function(data){
				window.console.log(data.competitions)
				_(disps).each(function(disp){
					var arr = self.parseCalendarData(data.competitions, disp)
					self.competitionList.push.apply(self.competitionList, arr)
				})
			}
		window.console.log(query)
		// If a competitionList was passed in, assume that we have a static list and just return a 
		// resolved promise, If no competitionList was passed, fire a getJSON request to get the 
		// calendar from eGroupware
		return (!this.competitionList.length) ? this.getJSON(query).then(parse) : Promise.resolve("Using Static List")
		// .then(function(){ window.console.log(self.competitionList) })
	},

	//
	//	parseCalendarData(): Parse the calendar returned from eGroupware
	//	Underscore sure has an ugly chaining syntax...
	//	TODO: Override this for Junior competitions, as the number of rounds differs between _JWM 
	//	and _JEM/_JEC events
	//
	parseCalendarData: function(calendar, discipline){
		// Use the category ids defined in the EGWCategory attribute to find whether a competition 
		// includes the specified  discipline and then set the number of rounds in the competition 
		// (2 or 3)
		var testCatId = this.attributes.EGWCategory[discipline].m[0],
			rounds    = (discipline === 'S') ? 2 : 3

		// Filter the list down to the selected discipline types, then reduce this down to the 
		// parameters required for rendering and lastly unwrap the underscore object
		return _.chain(calendar)
			.filter(function(comp){
				return _(comp.cats).some(function(cat){ return parseInt(cat.grp_id, 10) === testCatId })
			})
			.map(function(comp){
				var code = comp.short + ' (' + (comp.host_nation || 'TBA') +')'
				return { "wet_id" : comp.wet_id, "type"  : discipline, "name"  : code, "rnds"  : rounds }
			})
			.value()
	},

	//
	//	getCategories(): Return the category identifiers for the competition type (and if a youth 
	//	competition, the age group).
	//	NOTE: If not otherwise defined, this.attributes.ShowAgeGroup == 0
	//
	getCategories: function(){
		var cArr = this.attributes.EGWCategory[this.attributes.comp_type],
			ages = this.attributes.ShowAgeGroup,
			cObj = {}

		cObj.male   = cArr.m[ages]
		cObj.female = cArr.f[ages]
		return cObj
	}
});

// Extend the Settings model to include generic Ajax methods
_.extend(App.Settings.prototype, App.AjaxMixin)

//	-----------------------------------------------------
//	SettingsView...
//	-----------------------------------------------------
//
//	Settings view extending Backbone.js 'View' class
//
App.SettingsView = Backbone.View.extend({
	className	: 'a_panel hide',
	events		: function(){
		return Modernizr.touch ?
		{
			"touchend	li"					: "updateEGWComp",
			"click		input[type=radio]"	: "updateEGWRound"
		} :
		{
			"click		li"					: "updateEGWComp",
			"click		input[type=radio]"	: "updateEGWRound"
		}
	},

	//
	//	initialize(): Create a model (n.b. the model's initialize method will first look to fetch 
	//	any pre-existing settings from localStorage)
	//
	initialize: function(options){
		// initialize the view's model
		this.model = options.settings

		// Event handling
		// NOTE: May be redundant as none of the displayed model parameters can be altered other 
		// than through this view!
		this.listenTo(this.model, 'change', this.updateSettingsView, this)

		// Load the calendar and render the view (uses ES6 Promises for asynchrous operation)
		//var self = this, render = function(){ self.render() }
		//this.model.fetchEGWCalendarData().then(render)
    window.console.log(this)
    this.render()

	},

	//
	//	render(): Initial rendering of the view
	//	NOTE: The comp list here is 'quick and dirty': it could be replaced by a formal subview, in 
	//	which case certain events and the updateEGWComp() function could all be delegated down and 
	//	we'd not need to use data-* properties.
	//
	render: function(){
		var str  = document.getElementById('settings_template').textContent,
			frag = document.createDocumentFragment(),
			el

		// Render the underscore template and append it to the DOM
		this.el.innerHTML = str
		document.getElementById('header').appendChild(this.el)

		// If there are two rounds, then hide the 3rd button
		this.showRounds(this.model.get('comp_rnds'))

		// Populate the comp list and append it to the DOM
		_(this.model.competitionList).each(function(comp){
			el              = document.createElement('li')
			el.innerHTML    = comp.name
			el.dataset.comp = JSON.stringify([comp.wet_id, comp.type, (comp.rnds || 3)])
			frag.appendChild(el)
		})
		this.el.getElementsByTagName('ul')[0].appendChild(frag)

		// Call updateSettingsView to highlight the currently selected round
		this.updateSettingsView()
	},

	//
	//	updateEGWComp(): Update the EGWComp parameter on a user input. Parses a JSON object stored 
	//	as a data-* property of the DOM element clicked
	//
	updateEGWComp: function(){
		var el = event.target,
			ds = JSON.parse(el.dataset.comp)

		// Set the number of rounds shown in the SettingsView from the number of rounds stored for 
		// the comp in question
		this.showRounds(ds[2])

		// Save the new competition parameters and trigger an application-level event to close the 
		// SettingsView and (if the comp data has changed, load new results)
		this.model.save({ 'comp_name' : el.textContent, 'EGWComp' : ds[0], 'comp_type' : ds[1], 'comp_rnds' : ds[2] })
		this.trigger('appEvent:toggleSettingsView')
	},

	//
	//	updateEGWRound(): Update the EGWRound parameter from the form inputs on the view
	//
	updateEGWRound: function(){
		var n = parseInt(this.el.querySelector("[name='rnd']:checked").value, 10)	//	NOTE: .value returns a string

		this.model.save({ 'EGWRound' : n })
		this.trigger('appEvent:toggleSettingsView')
	},

	//
	//	updateSettingsView(): Update the view from the current state of the model (triggered by changes to the model)
	//
	updateSettingsView: function(){
		var x = this.model.get('EGWRound')

		this.el.querySelector('#r'+x).checked = true
	},

	//
	//	toggleViewState(): Toggle the visibility state of the SettingsView
	//
	toggleViewState: function(){
		this.el.classList.toggle('show')
		this.el.classList.toggle('hide')
	},

	//
	//	showRounds(): Modify the display state depending upon whether there are 2 or 3 rounds (defaults is 3)
	//
	showRounds: function(n){
		var two = parseInt(n ,10) === 2,
			obj = two ? { t: 'Final', d: 'none', w: '49%' } : { t: "Semi'", d: 'inline-block', w: '32%' },
			Arr = this.el.getElementsByTagName('label')

		// Set the display state
		Arr[1].textContent   = obj.t
		Arr[2].style.display = obj.d
		_(Arr).each(function(el){ el.style.width = obj.w })

		// If we're switching to a 2 round competition and the currently selected round is not 
		// qualification, then make sure we activate a valid round on transfer
		if (two && this.model.get('EGWRound')) { this.model.set({ 'EGWRound' : 2 }) }

		// TODO: Adding {silent : true} should prevent updateSettingsView being called twice, but 
		// need to test this...
		// if (two && this.model.get('EGWRound')) { this.model.set({ 'EGWRound' : 2 }, { silent : true}) }
	}
})

//	MVC style coding for a dynamic presentation of competition results
//	Copyright 2012-14  T J Hatch
//
//	Licensed under the Apache License, Version 2.0 (the "License");
//	you may not use this file except in compliance with the License.
//	You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
//	Unless required by applicable law or agreed to in writing, software
//	distributed under the License is distributed on an "AS IS" BASIS,
//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//	See the License for the specific language governing permissions and
//	limitations under the License.

//	-----------------------------------------------------
//	CODEKIT DECLARATIONS
//	-----------------------------------------------------
/* global Modernizr */
/* global Backbone */
/* global _        */
/* global App      */
//	-----------------------------------------------------
//	SCOPE DECLARATIONS
//	-----------------------------------------------------
var App = App || {}

//	-----------------------------------------------------
//	HeaderView...
//	-----------------------------------------------------
//
//	Header view extending Backbone.js 'View' class
//	This is a simple view to trigger the interchange of views. It's pre-rendered & mainly acts by 
//	messaging the applicationObject. The view's methods toggle its visible state
//
App.HeaderView = Backbone.View.extend({
	events	: function(){
		return Modernizr.touch ?
		{
			'touchend span.icn'			: 'toggleSettingsView',
			'touchend span.cat'			: 'toggleShowCategory',
			'touchend span.fav'			: 'toggleShowFavorites',
		} :
		{
			'click span.icn'			: 'toggleSettingsView',
			'click span.cat'			: 'toggleShowCategory',
			'click span.fav'			: 'toggleShowFavorites',
		}
	},

	//
	//	toggleShowCategory(): Toggle the displayed category (and update the settings model 
	//	accordingly)
	//	NOTE: Requires an object, containing properties: 'showCategory' and 'showFavs'
	//
	initialize: function(options){

		// Init Properties
		this.settings      = options.settings
		this.showCategory  = this.settings.get('ShowCategory') ? 'm-tag' : 'f-tag'
		this.showFavorites = this.settings.get('ShowFavorites') ? 'icon-tag' : 'icon-tag-empty'

		// Init Events
		this.listenTo(this.settings, 'change:comp_name', this.setWindowTitle, this)

		// Init Render
		this.render()
	},

	//
	//	setWindowTitle(): Set the window title... Called by an event listener (see above in 
	//	initialize() when the selected competition is changed by a user input
	//
	setWindowTitle: function(){
		this.el.getElementsByClassName('cmp')[0].innerHTML = this.settings.get('comp_name')
	},

	//
	//	render(): Render the header view
	//
	render: function(){
		var parent = document.getElementById('header'),
			tmpl   = document.getElementById('header_template').textContent,
			str

		// Render the view template and append it to the DOM
		str = _.template(tmpl, {
			'comp_name'     : this.settings.get('comp_name'),
			'showCategory'  : this.showCategory,
			'showFavorites' : this.showFavorites
		})
		this.el.innerHTML = str
		parent.insertBefore(this.el, parent.firstChild)
	},

	//
	//	toggleSettingsView(): Trigger an application level event to toggle the view state (the 
	//	event is caught at application level)
	//
	toggleSettingsView: function(){
		//var el = this.el.querySelector('span.icn')
		//el.classList[(!window.navigator.onLine) ? 'add' : 'remove']('offline')

		this.trigger('appEvent:toggleSettingsView')
	},

	//
	//	toggleShowCategory(): Toggle the displayed category (and update the settings model 
	//	accordingly)
	//
	toggleShowCategory: function(){
		var el = this.el.getElementsByClassName('cat')[0],
			cat

		// toggle the icon 'button' between male & female states
		el.classList.toggle('m-tag')
		el.classList.toggle('f-tag')

		// Change the model state to reflect the selected display option
		cat = el.classList.contains('m-tag') ? 1 : 0
		this.settings.save({ 'ShowCategory' : cat })
	},

	//
	//	toggleShowFavorites(): Toggle the displayed climbers (all or favourites) and update the 
	//	settings model
	//
	toggleShowFavorites: function(){
		var el = this.el.getElementsByClassName('fav')[0],
			fav

		// toggle the icon 'button' between active and inactive states
		el.classList.toggle('icon-tag')
		el.classList.toggle('icon-tag-empty')

		// Change the model state to reflect the selected display option
		fav = el.classList.contains('icon-tag') ? 1 : 0
		this.settings.save({ 'ShowFavorites' : fav })
	}
});


//	MVC style coding for a dynamic presentation of competition results
//	Copyright 2012-14  T J Hatch
//
//	Licensed under the Apache License, Version 2.0 (the "License");
//	you may not use this file except in compliance with the License.
//	You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
//	Unless required by applicable law or agreed to in writing, software
//	distributed under the License is distributed on an "AS IS" BASIS,
//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//	See the License for the specific language governing permissions and
//	limitations under the License.

//	-----------------------------------------------------
//	CODEKIT DECLARATIONS
//	-----------------------------------------------------
/*global App      */

//	-----------------------------------------------------
//	Application Object...
//	-----------------------------------------------------
//
//	Wrap eveything in a singleton object
//
window.applicationObject = {

	//
	// 	init() - Initialize the application object
	//	Create the a model to store application settings and the various application views
	//	Force disabling of ajax caches (IOS 6.x aggressively caches data)
	//
	init: function(idx, options){
		// Scale to the screen (where not handled by the browser automatically)
		this.scaleToScreen()

		// Initialise in order the settings model and then each of the application views:
		// 1) settingsView, accessing the application settings and containing the settings model
		// 2) headerView, controlling the application views/models -
		// 3) resultsView, displaying the results
		// Pass the settings model allowing them to (make and) respond to changes within without
		// application level event mediation.
		this.settings     = new App.Settings({ 'id' : idx }, options)

		this.settingsView = new App.SettingsView({ 'settings' : this.settings })
		this.headerView   = new App.HeaderView({ 'settings' : this.settings })
		this.resultsView  = new App.ResultsListView({ 'settings' : this.settings })

		// Handle events not handled within any individual view
		this.handleApplicationEvents()
	},

	//
	//	handleApplicationEvents(): Manage message passing for events that require an action in a 
	//	view other than that where they originated. Load new results (if required) and Hide/Show 
	//	the SettingsView following either (1) a swipe/double-tap in the ResultsListView; (2) based 
	//	on an action in either the SettingsView or HeaderView.
	//
	handleApplicationEvents: function(){
		// Handle events changing the view state of the SettingsView
		this.resultsView
			.on('appEvent:toggleSettingsView', this.toggleSettingsView, this)
		this.settingsView
			.on('appEvent:toggleSettingsView', this.toggleSettingsView, this)
		this.headerView
			.on('appEvent:toggleSettingsView', this.toggleSettingsView, this)
	},

	//
	//	toggleSettingsView(): Toggle the settingsView window and call 
	//	resultsView::initResultsListView if the comp ID,
	//	round or competition type (boulder/lead/speed) have been changed by a user input
	//
	toggleSettingsView: function(){
		// If any settings have changed, fetch new data from eGroupware
		var a = (this.resultsView.currentComp  !== this.settings.get('EGWComp')),
			b = (this.resultsView.currentRound !== this.settings.get('EGWRound')),
			c = (this.resultsView.currentCType !== this.settings.get('comp_type'))
		if (a || b || c) { this.resultsView.initResultsListView() }

		// Toggle the view state of the settingsView
		this.settingsView.toggleViewState()
	},

	//
	//	scaleToScreen(): A dummy scaling function - Screen scaling is handled automatically by 
	//	mobile browsers throug the <meta viewport tag, so this function is only needed for desktop 
	//	implementations. Desktop applications will need to override this function
	//
	scaleToScreen: function(){}
}

//	MVC style coding for a dynamic presentation of competition results
//	Copyright 2012-14  T J Hatch
//
//	Licensed under the Apache License, Version 2.0 (the "License");
//	you may not use this file except in compliance with the License.
//	You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
//	Unless required by applicable law or agreed to in writing, software
//	distributed under the License is distributed on an "AS IS" BASIS,
//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//	See the License for the specific language governing permissions and
//	limitations under the License.

//	-----------------------------------------------------
//	CODEKIT DECLARATIONS
//	-----------------------------------------------------
/* global App      */
/* global Backbone */
//	-----------------------------------------------------
//	SCOPE DECLARATIONS
//	-----------------------------------------------------
var App = App || {}

//	-----------------------------------------------------
//	Climber...
//	-----------------------------------------------------
//
//	Climber model extending Backbone.js 'Model' class
//
App.Climber = Backbone.Model.extend({
	// Currently no common methods / properties
})

//	-----------------------------------------------------
//	ClimberView...
//	-----------------------------------------------------
//
//	Climber view extending Backbone.js 'View' class
//
App.ClimberView = Backbone.View.extend({
	tagName		: 'li',
	className	: 'ntg',

	//
	// 	initialize(): Trigger the view's update method if the associated model is changed
	// 	NOTE: The association between model & view is made in the superview's initialize method
	//
	initialize: function(){
		// Bind the ::update function to any change in the related model.
		this.listenTo(this.model, 'change', this.update, this)

		// Finish initialization by rendering and updating the view from the relevant model data
		this.render()
		this.update()
	},

	//
	//	close(): Safely remove the window, GC references to the view
	//
	close: function(){
		// Remove all local event bindings - no effect in this instance as there are none
		// !important - Remove the view from the DOM and remove any bound model events
		this.unbind()
		this.remove()

		// Delete in-memory references to the el, see
		// http://andrewhenderson.me/tutorial/backbone-memory-leaks-zombie-views/
		// But not sure how important these are...
		;delete this.$el
		;delete this.el
	}
})

//	MVC style coding for a dynamic presentation of competition results
//	Copyright 2012-14  T J Hatch
//
//	Licensed under the Apache License, Version 2.0 (the "License");
//	you may not use this file except in compliance with the License.
//	You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
//	Unless required by applicable law or agreed to in writing, software
//	distributed under the License is distributed on an "AS IS" BASIS,
//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//	See the License for the specific language governing permissions and
//	limitations under the License.

//	-----------------------------------------------------
//	CODEKIT DECLARATIONS
//	-----------------------------------------------------
/* global Promise	*/
/* global _			*/
/* global Backbone	*/
/* global App		*/
/* global Modernizr */
//	-----------------------------------------------------
//	SCOPE DECLARATIONS
//	-----------------------------------------------------
// var App = App || {}

//	-----------------------------------------------------
//	ResultsList...
//	-----------------------------------------------------
//
//	Extend the Backbone.js 'Collection' class
//
App.ResultsList = Backbone.Collection.extend({

	model : App.Climber,
	//
	//	initialize()
	//
	//	NOTE: Mandatory input parameter is a reference to the application settings model 
	//	(options.settings)
	//	NOTE: Optional input parameters are the round and category for display
	//
	initialize: function(options){
		this.settings = options.settings

		// Use the options data to set the round/category, and set the comp based on the 
		// application settings
		this.comp  = this.settings.get('EGWComp')
		this.type  = this.settings.get('comp_type')
		this.round = options.round || this.settings.get('EGWRound')
		this.cat   = options.cat
		this.SG2   = (this.round === 1) ? 1 : 0

		// Store the categories relevant to the round
		this.cObj  = options.cObj

		// Set constants used in function calls e.g. ::setResults()
		// = Number of boulders
		this.NB    = this.settings.get('Boulders')[this.settings.get('EGWRound')]	
		// = Booleans for Speed Final, Lead Qualification, Lead Final
		this.SF    = (this.type === 'S' && !!this.round)
		this.LQ    = (this.type === 'L' && !this.round)
		this.LF    = (this.type === 'L' && (this.round === this.settings.get('comp_rnds')))

		// Call updateFavoritesList() if any model in the collection fires a change:is_tagged event
		this.on('change:is_tagged', this.updateFavoritesList, this.settings)
	},

	//
	//	loadResults(): Fetch results data from eGroupware and populate the collection
	//	Uses the default entry point to eGroupware specifying the comp, category and round
	//
	loadResults: function(){
		var query = '?wet_id='+this.comp+'&grp_id='+this.cat+'&route='+this.round,
			self  = this, func = function(data){
				self.parseJSONData(data)
				self.reset(data)
				self.setRankPrevHeat()
				self.sortResults(data)
			}

		return this.getJSON(query).then(func)
	},

	//
	//	loadStarters(): Fetch results data from eGroupware and populate the collection
	//	Uses the &type=starters option to fetch the list of registered climbers
	//
	loadStarters: function(){
	},

	//
	//	update(): Fetch climber data from the server and update the collection
	//	Behaviour:
	//	For most cases: Boulder (all rounds), Lead (all rounds) and Speed (qualification) we 
	//	retrieve the eGroupware response for that specific round (e.g. using the &route=[*] 
	//	parameter). This is efficient in terms of data usage, as only the result for the 
	// competitors in that round is retrieved, but it does give some inefficiencies. For the Speed 
	// Final, we can't do this so easily, as the final can have anywhere from 3 to 5 stages so we 
	// have an unknown number of 'rounds' to retrieve. So in this case, we retrieve the "General 
	// Result", submitting the request without the '&route' parameter
	//
	update: function(){
		var	round = this.round,
			query = '?wet_id='+this.comp+'&grp_id='+this.cat,
			self  = this, func = function(data){ self.sortResults(data) }

		// Set the url to access either the specific round or the General Result
		query += ((this.LQ || this.SF) ? '' : '&route='+round)

		// Set the results data for each climber (model) in the collection, then sort the collection
		return this.getJSON(query).then(func)
	},

	//	---------------------------------------------------------------------------------------------------------------
	//	Data Parsing & Sorting Methods -
	//	---------------------------------------------------------------------------------------------------------------
	//
	//	parseJSONData(participants): Parse the JSON data returned in loadResults()
	//
	parseJSONData: function(participants){
		var mcat  = this.cObj.male,
			lchr

		// For each entry in the .participants object
		_(participants).each(function(person, i){
			lchr = _(person.lastname).last()
			if (lchr === lchr.toUpperCase()) { person.lastname = _.titleize(person.lastname) }
			lchr = _(person.firstname).last()
			if (lchr === lchr.toUpperCase()) { person.firstname = _.titleize(person.firstname) }

			// Add new properties (a) as the model id and (b) to indicate the starting group
			person.id             = parseInt(person.per_id, 10)
			person.is_tagged      = (_.indexOf(this.settings.get('FavoritesList'), person.id) > -1)

			// Edit properties , e.g. where ints/floats are stored as strings
			person.cat            = mcat === (person.cat || this.cat)
			// Rely on the original order if not defined
			person.start_order    = parseInt(person.start_order, 10) || i+1	
			person.rank_prev_heat = parseFloat(person.rank_prev_heat) || null

			// Delete properties that aren't used
			;delete person.birthyear
			;delete person.city
			;delete person.federation
			;delete person.fed_url
			;delete person.qoints
			;delete person.result_modified
			;delete person.reg_fed_id
			;delete person.start_number
			;delete person.url
		}, this)
	},

	//
	//	setResults(participants): Set calculated results & sorting parameters for each model, 
	//	then sort the collection using the 'sort_value' parameter stored for each model within the
	//  collection and update parameters used by the model view by calling setDisplayValues() 
	//	and setDisplayTime() so that the model views update.
	//
	sortResults: function(participants){
		var _setResults = '_set'+this.type+'Results',
			opts        = {}

		// Iterate across each person in the participants object to set calculated properties 
		// required for sorting & displaying results
		_(participants).each(function(person){
			// Get the general results data
			opts.rank = parseInt(person.result_rank, 10)
			opts.prev = parseFloat(person.rank_prev_heat) || parseInt(person.start_order, 10)

			// Set the related model parameters
			this[_setResults](person, opts)
		}, this)

		// Re-order the collection's models using an insertion sort algorithm - this should be 
		// sufficiently fast:
		// (a) the models are initially loaded in starting order (if the round has not started); and
		// (b) once the round has started, the first 'sort' may affect all elements, but subsequent
		// sorts should only be incremental.
		// !important: We pass a comparator function as an argument to the insertionsort() function
		_(this.models).insertionsort(function(a, b){ return (a.get('sort_value') > b.get('sort_value')) })

		// Call setDisplayValues() to set model attributes appearing in the view.
		this.setDisplayValues()
	},

	//
	//	Private methods called from setResults() to set results data for specific disciplines
	//
	_setBResults: function(person, options){
		var model   = this.get(parseInt(person.per_id, 10)),
			sortval = options.rank || this.length + options.prev,
			rArr    = [], i
      
    var o = {}
    if (person.result_json.length) o = JSON.parse(person.result_json)
    
		// Push the results for each bloc into an array
		for (i = 1; i <= this.NB; i++) { rArr.push(o['p'+i] || null) }

		// Get the model and set its results parameters
		model.set({
			'rArr'		: rArr,
			'result'	: person.result || null,
			'sort_value': sortval || null
		})
	},
	_setLResults: function(person, options){
		var model   = this.get(parseInt(person.per_id, 10)),
			sortval = options.rank || (this.length + options.prev)

		// If it's the qualification round (i.e. we're fetching the General Result)
		if (this.LQ) {

			// 2 Qualification in series has no result0 parameter until the second route starts, so fix this
			if (!person.result0 && !person.result1) { person.result0 = person.result }

			// Set the effective rank parameter (for sorting). If we are looking either: (a) the
			// qualification round after it has completed; or (b) a 2-route serial qualification
			// round is in progress, and at least one climber has started the second route, then
			// the 'quali-points' property will exist and we can use that. In the case of (a), we
			// have to use it anyway as the options.rank parameter will change as a consequence of 
			// results in later rounds) If the "quali_points" parameter doesn't exist then either
			// (a) a 2-route parallel qualification round is in progress, or (b) a 2-route serial
			// qualification round is in progress, but the second route has not yet started and we
			// just use the options.rank parameter as initially set
			if (person.quali_points !== undefined) { sortval = parseFloat(person.quali_points) }

			// The overall ranking is not calculated when data has been entered for only one route 
			// in a 2-route parallel qualification round. We can fix this by making sortval = the 
			// rank on the one route completed.
			if (sortval === 1) {
				if (person.result0 === undefined) sortval = parseInt(person.result_rank1, 10) || 0.9
				if (person.result1 === undefined) sortval = parseInt(person.result_rank0, 10) || 1.1
			}
		}

		// Set the model's results properties. Use a try block because (in the qualification round) 
		// the collection is initially populated from the &route=0 response, and updates are 
		// gathered from the General Result - in theory the latter should be a subset of the 
		// former, but try... catch... is safe. Technically we don't need a try... catch.. for the 
		// semifinal and final, as for these rounds we collect data for the round itself, but it 
		// does no harm
		try {
			model.set({
				'result'	: person.result || null,
				'result0'	: person.result0 || null,
				'result1'	: person.result1 || null,
				'res_rank0'	: person.result_rank0 || null,
				'res_rank1'	: person.result_rank1 || null,
				'sort_value': sortval || null,
				'time'		: parseFloat(person.time) || null
			})
		}
		catch (err) { window.console.log('not in collection (per_id): '+person.per_id) }
	},
	_setSResults: function(person, options){
		var model   = this.get(parseInt(person.per_id, 10)),
			sortval = options.rank || (this.length + options.prev),
			rank

		// Iterate across the results for each stage in the speed final
		if (this.SF) {
			// Set the basic rank & result parameters
			rank          = person.result_rank6 || person.result_rank5 || person.result_rank4 || person.result_rank3 || person.result_rank2
			person.result = person.result6 || person.result5 || person.result4 || person.result3 || person.result2

			// Throw in an experimental loop that we can use to show when the competitor was eliminated
			//var last, m, n = 6
			//while (n > 1) {
			//	if (!!person['result'+n]) { m = n; break }
			//	n--
			//}
			//if (!!this.rts[m]) last = this.rts[m]
			//window.console.log(last)
		}

		// Abbreviate the result text where the climber has been eliminated for 2 False Starts.
		if (person.result === "2. false start") person.result = "2 FS"

		// Set the model's results parameters. Use a try block because the General Result will 
		// contain competitors not in the final round i.e. they won't have a corresponding model in 
		// the collection and a model.set() call will error out
		try {
			model.set({
				'result'	: person.result || null,
				'sort_value': sortval || null,
				'result_l'	: person.result_l ? person.result_l : null,
				'result_r'	: person.result_r ? person.result_r : null,
				'elim'		: (rank !== "1")
				//'lastround' : last || null
			})
		}
		catch (err) { window.console.log('not in collection (per_id): '+person.per_id) }
	},

	//	-------------------------------------------------------------------------------------------
	//	Setter Methods -
	//	-------------------------------------------------------------------------------------------
	//
	//	setRankPrevHeat(): Calculate the rank from the previous heat. We implement this method 
	//	specifically for lead competitions and for the round following qualification, where 
	//	eGroupware provides the rank_prev_heat property as the qualification points calculated for 
	//	the climber rather than an actual rank.
	//
	setRankPrevHeat: function(){
		var l    = this.length,
			rArr = [],
			i, j, cr

		// Exit if the comp is not a lead comp; or if the round does not immediately follow
		// qualification
		if (!(this.type === 'L' && this.round === 2)) { return }

		// Create a temporary array containing the rank_prev_heat data (as this will be 
		// overwritten) and run an insertion sort across the temporary array to order by the prior 
		// rank
		// !important: We pass a comparator function as an argument to the insertionsort() function
		this.each(function(model){ rArr.push([model.get('rank_prev_heat'), model.get('id')]) })
		_(rArr).insertionsort(function(a,b){ return (a[0] > b[0]) })

		// Traverse the temporary array & set new values for the 'rank_prev_heat' property of the 
		// relevant models
		for (i = 0, j = 1, this.get(rArr[0][1]).set({ 'rank_prev_heat' : 1 }); j < l; i++, j++) {
			cr = (rArr[i][0] === rArr[j][0]) ? this.get(rArr[i][1]).get('rank_prev_heat') : j+1
			this.get(rArr[j][1]).set({ 'rank_prev_heat' : cr })
		}
	},

	//
	// setDisplayValues(): Set the 'calculated_rank' and 'display_order' model properties
	// !important: This function requires the collection to have been sorted prior to invocation
	// !important: We define and use a new property 'calculated_rank' in preference to using the 
	// 'result_rank' property that is retrieved from eGroupware, because this 'result_rank' 
	// property is mutable. i.e. (specifically in the case of Lead, where we use the General Result 
	// to obtain the results on each qualification route) the 'result_rank' property can change as 
	// between rounds and so the result retrieved from eGroupware may not be that applicable for 
	// the round that's being looked at
	//
	setDisplayValues: function(){
		var a = this.models,
			l = this.length,
			i, j, cr

		// Iterate across the models setting rank and display ordering parameters
		for (i = 0, j = 1, a[0].set({ 'calculated_rank' : 1, 'display_order' : 1 }); j < l; i++, j++) {
			cr = (a[i].get('sort_value') === a[j].get('sort_value')) ? a[i].get('calculated_rank') : (j+1)
			a[j].set({ 'calculated_rank' : cr , 'display_order' : cr })
		}

		// Call setDisplayTime() to show time in (only for the Lead Final)
		if (this.LF) this.setDisplayTime()
	},
	//_setMOrder: function(i, cr){ this.models[i].set({ 'calculated_rank' : cr , 'display_order' : cr }) },
	//_setDOrder: function(i, cr){ this.models[i].set({ 'calculated_rank' : cr , 'display_order' : i+1 }) },

	//
	//	setDisplayTime(): Assign a 'true | false' flag to each model to indicate whether time is 
	//	relevant in the final.
	//	!important: This function requires the collection to have been sorted prior to invocation
	//	We set attributes directly - rather than using .set() - which may be naughty but is 
	//	substantially faster.
	//
	setDisplayTime: function(){
		var a = this.models,
			l = this.length,
			i, j

		// Set the 'timeflag' of the first element to false and then iterate across the models, 
		// [0]th to [n-1]th and set timeflags == true for the the [r]th and [r+1]th elements if the 
		// results are equal and they were tied in a prior round. If neither of these things are 
		// true, then set the timeflag of the [r+1]th element to false: The timeflag for the [r]th 
		// element may be true or false depending on the results of a previous test (e.g. if it's 
		// the same as [r-1]th element)
		for (i = 0, j = 1, a[0].set({ 'time_flag' : false }); j < l; i++, j++) {
			if (a[i].get('result') === a[j].get('result') && a[i].get('rank_prev_heat') === a[j].get('rank_prev_heat')) {
				a[i].set({ 'time_flag' : true })
				a[j].set({ 'time_flag' : true })
			} else {
				a[j].set({ 'time_flag' : false })
			}
		}
	},

	//	-------------------------------------------------------------------------------------------
	//	Event Handlers -
	//	-------------------------------------------------------------------------------------------
	//
	// updateFavoritesList():
	// NOTE: the event binder calls this function with this.settings as its scope, so we need only 
	// use this.get and not this.settings.get
	//
	updateFavoritesList: function(model){
		var arr    = this.get('FavoritesList'),
			person = model.get('id')

		// If the model is_tagged parameter is TRUE, push the model id onto the favourites list, 
		// otherwise remove it, then save the list
		if (model.get('is_tagged')) { arr.push(person) } else { arr = _(arr).without(person) }
		this.save({ 'FavoritesList' : arr })
	}
});

// Extend the ResultsList collection to include generic Ajax methods, specifically getJSON
_.extend(App.ResultsList.prototype, App.AjaxMixin)

//	-----------------------------------------------------
//	ResultsListView...
//	-----------------------------------------------------
//
//	Extend the Backbone.js 'View' class
//	Uses Mixins to modularise the class code
//
App.ResultsListView = Backbone.View.extend({

	currentView		: null,
	id				: 'wrapper',
	className		: 'resultslistview',
	events			: {
		'click .cbox' : 'handleTaggingEvent'
	},

	//
	//	initialize() : Create the containing view for the collection of individual model views
	//	The view is initialized by passing the following options: "settings"
	//
	//	!Important - The backbone options parameter is used to allow the view to reference the
	//  application settings
	//
	initialize: function(options){
		// Store a reference to the application settings
		this.settings = options.settings

		// Update the view if the favourites button is toggled
		this.listenTo(this.settings, 'change:ShowFavorites', this.animateDOM, this)
		this.listenTo(this.settings, 'change:ShowCategory', this.handleCategoryChange, this)
		this.listenTo(this.settings, 'change:ShowAgeGroup', this.initResultsListView, this)

		// Initialise Hammer.js & start listening for touch/drag events
		this.initDragManager()

		// Load Results
		this.initResultsListView()
	},

	//
	//	close(): Clean out the view when it is closed
	//
	close: function(){
		// Clean up all the subviews
		_(this.subviews).each(function(subview){ subview.close() }, this)
	},

	//	-------------------------------------------------------------------------------------------
	//	View Initialisation & Update Methods
	//	-------------------------------------------------------------------------------------------
	//
	//	initResultsListView(): Populate the results collections and render the related subviews 
	//	into the main view called each time the app is loaded, or when a new competition or round 
	//	is selected by the user
	//
	initResultsListView: function(){
		var _initResultsArray = '_init'+this.settings.get('comp_type')+'ResultsArray'

		// Record the current view parameters
		this.currentComp  = this.settings.get('EGWComp')
		this.currentRound = this.settings.get('EGWRound')
		this.currentCType = this.settings.get('comp_type')
		this.categoryObj  = this.settings.getCategories()

		// Create or reset an array of collection (ResultsLists) objects and a startlist object
		this.resultslists = []
		this.starters     = null

		// Call the discipline-specific _init[*]ResultsArray() function to populate the 
		// resultslists array
		this[_initResultsArray]()

		// Render the view container & set the statusBarHeight == 24 to indicate that data is 
		// loading
		this.renderSuperView()
		this.setStatusBarHeight(24)

		// Call the fetchViewContent() function to get data from the server and render subviews
		this.fetchViewContent()
	},

	//
	//	Private methods called from initResultsListView() to create the view's collections (each a 
	//	ResultsList object)
	//
	_initBResultsArray: function(){
		// Set up the variables for the first object to be fetched
		var cat1  = this.settings.get('ShowCategory') ? this.categoryObj.male : this.categoryObj.female,
			cat2  = (cat1 === this.categoryObj.male) ? this.categoryObj.female : this.categoryObj.male,
			round = this.currentRound

		// Call pushCollections to load two collections
		this.pushNewCollection(cat1, round)
		if (!this.currentRound) { round++ ; cat2 = cat1 }
		this.pushNewCollection(cat2, round)
	},
	_initLResultsArray: function(){
		// Set up the variables for the first object to be fetched
		var cat1  = this.settings.get('ShowCategory') ? this.categoryObj.male : this.categoryObj.female,
			cat2  = (cat1 === this.categoryObj.male) ? this.categoryObj.female : this.categoryObj.male,
			round = this.currentRound

		this.check_cats = [cat1, cat2]
		// Call pushNewCollection to load a collection into the resultslists array
		this.pushNewCollection(cat1, round)

		// Load a second collection if (a) it's the semifinal/final; or (b) a desktop display (to display both cats)
		if (!!round || this.settings.isFullScreenApp) { this.pushNewCollection(cat2, round) }

		// Finally, deal with the exceptional case of the World Championship format, where we have 
		// 2 sub-competitions in the qualification round (as there field is split into 2).
		// Create a 2nd collection if we're in Qualification and we're not on the Desktop; then 
		// overwrite the default competition and category parameters for the collections before 
		// we load any data
		// TODO: Integrate this into the application structure, rather than hard-wiring...
//		if (this.currentComp === 1500 && !round) {
//			if (!this.settings.isFullScreenApp) { this.pushNewCollection(cat1, round) }
//			this.resultslists[0].comp = 1595 // 1458 //
//			this.resultslists[1].comp = 1596 // 1525 //
//			this.resultslists[1].cat  = cat1
//			this.resultslists[1].SG2  = 1
//		}
	},
	_initSResultsArray: function(){
		// Set up the variables for the first object to be fetched
		var cat1  = this.settings.get('ShowCategory') ? this.categoryObj.male : this.categoryObj.female,
			cat2  = (cat1 === this.categoryObj.male) ? this.categoryObj.female : this.categoryObj.male,
			round = this.currentRound

		// Push a single collection onto the array for the selected round
		this.pushNewCollection(cat1, round)

		// and if we're using the desktop app, collect another collections (so that we have both
		// categories)
		if (this.settings.isFullScreenApp) { this.pushNewCollection(cat2, round) }
	},

	//
	//	pushNewCollection(category, round): Create two collection objects and push them into the 
	//	resultslist array called from _init[*]ResultsArray() methods
	//
	pushNewCollection: function(category, round){
		// Create a new collection for the first set of data to be fetched
		this.resultslists.push(new App.ResultsList({
			'settings'	: this.settings,
			'round'		: round,
			'cat'		: category,
			'cObj'		: this.categoryObj }))
	},

	//
	//	fetchViewContent():  call the collection.loadResults() method, render the associated 
	//	subviews and then sort/update the views
	//
	fetchViewContent: function(){
		var promise, promiseArray = [],
			SF   = (this.currentCType === 'S' && !!this.currentRound),
			LQ   = (this.currentCType === 'L' && !this.currentRound),
			self = this, message

		// Fetch results from the server for each collection. Also pass the index number of the 
		// collection (needed by the renderSubViews() method)
		_(this.resultslists).each(function(collection, i){
			promise = collection.loadResults()
			.then(function(){ 
				// TODO: Put a check here to prevent rendering where data is not current 
				window.console.log(self.check_cats + ' ' + collection.retrieved_cat)
				window.console.log(self.currentComp + ' ' + collection.comp)
				window.console.log(self.currentRound + ' ' + collection.round)
				//
				self.renderSubViews(collection, i) 
			})
			.catch(function(err){ 
				window.console.log('caught in fetchViewContent:'); 
				/* window.console.log(err); */ 
				message = err 
			})
			promiseArray.push(promise)
		})

		// Now perform any actions that need all asynchronous actions to have been completed
		// i.e. When all promises in the array been have resolved (i.e. when we have rendered all
		// subviews)
		Promise.all(promiseArray).then(function(){
			// window.console.log('all promises resolved')
			if (!!self.subviews.length) {
				// If we're using the General Result for results updates, we'll need to pull that 
				// in. Otherwise just update the view. See also ResultsList::update() for when the 
				// General Result ia used
				self.updateViewContent({ force_refresh : (LQ || SF) ? true : false })
				// If we're running the desktop app, then start the autoRefresh...
				if (self.settings.isFullScreenApp) { self.autoRefresh() }
			}
			// Otherwise get the list of any climbers registered for the comp' or put up an error 
			// message
			else { self[(!self.settings.get('EGWRound')) ? 'renderStartlist' : 'renderXHRError']() }
		})
	},

	//
	//	updateViewContent(options): call the collection.update() method and then update the view
	//	Behaviour:
	//	if options.force_refresh == true, fetch new results data from the server and then call 
	//	this.animateDOM(); or if options.force_refresh is undefined || false, call this.animateDOM()
	//
	updateViewContent: function(options){
		var promise, promiseArray = [],
			self = this
		// window.console.log(this.resultslists)
		// If force_refresh == true, then get new results from the server
		options = options || {} // OR options || (options = {})
		if (options.force_refresh) {
			_(this.resultslists).each(function(collection){
				promise = collection.update()
				.catch(function(err){ window.console.log(err +' caught in updateViewContent:') })
				promiseArray.push(promise)
			}, this)
		}

		// But in all cases, perform a visual sort & hide the statusbar
		Promise.all(promiseArray).then(function(){
			self.animateDOM()
			self.hideStatusBar()
		})
	},

	//	-------------------------------------------------------------------------------------------
	//	Render Methods -
	//	-------------------------------------------------------------------------------------------
	//
	//	renderSuperView(): Render the view container
	//
	renderSuperView: function(){
		// Clean up any existing views if render is being called other than the first time
		if (this.currentView) { this.close() }
		this.subviews = []

		// Create the shell of the view & append to the DOM. This overwrites any existing content.
		this.el.innerHTML = _.template(document.getElementById('rlv_template').textContent, {})
		document.body.appendChild(this.el)

		// Create references to the current view and to the list elements within the view
		this.currentView  = this.el
		this.resultsView  = this.el.getElementsByTagName('ul')
	},

	//
	//	renderSubViews(): Render the climber subviews.
	//	Takes as inputs a collection (of climber models) and the index of the collection within the 
	//	resultslist array.
	//	The method then determines which list element view into which it needs to render:
	//	NOTE: The mobile-format display always renders into the first (and only) <ul> element
	//	NOTE: The desktop-format display always renders into two <ul> elements, 0 and 1 (determined 
	//	by the collection's	index) represented by the idx parameter
	//
	renderSubViews: function(collection, i){
		var viewtype = this.settings.get('comp_type')+"ClimberView",
			frag     = document.createDocumentFragment(),
			index    = (this.settings.isFullScreenApp && i) ? 1 : 0,
			offset   = (collection.round === 1) ? 1000 : 0,
			o, subview

		// Iterate through the collection and:
		// Create a new subview (the subview initialisation method takes care of rendering) 
		// and append it to a list of subviews (for garbage collection when the superview is 
		// re-rendered)
		// Set a 'data-load' attribute with a unique value (we need this for a stable sort of 
		// the DOM) in animateDOM(). The 'offset' value forces startgroup 2 to display after 
		// startgroup 1
		// Finally, append to the document fragment		
		collection.each(function(model){
			subview = new App[viewtype]({ model : model })
			this.subviews.push(subview)
			o = this.subviews.length + offset
			subview.el.setAttribute('data-load', o)
			frag.appendChild(subview.el)
		}, this)

		// Append the document fragment to the cached parent object...
		this.resultsView[index].appendChild(frag)

		// Enable chaining
		return this
	},

	//
	//	renderStartlist(): Fetch startlist data and then render the associated views (or an error
	//	message)
	//
	renderStartlist: function(){
		var self = this

		// Instatiate the startlist collection object
		this.starters = new App.ResultsList({ 'settings' : this.settings, 'cObj' : this.categoryObj })

		// Call the collection's loadStarters() method and when done, style the ClimberViews (null 
		// the rank and hide the favourites button)
		this.starters.loadStarters()
		.then(
			// On success : render the list and call updateViewContent()
			function(){ 
				if (self.starters.length) { 
					self.renderSubViews(self.starters).updateViewContent() 
				} else { self.renderXHRError() }
			},
			// On failure : call the renderXHRError() method
			function(){ self.renderXHRError() })
		.then(function(){
			_(self.el.getElementsByClassName('rank')).each(function(el){ el.textContent = '' })
			_(self.el.getElementsByClassName('fav')).each(function(el){ el.style.visibility = 'hidden' })
		})
	},

	//
	//	renderXHRError(): Render an error message when no data can be loaded
	//
	renderXHRError: function(){
		var onl = "Network Error : Data may not exist or Server is unavailable",
			ofl = "Network Disconnected (and requested data not in memory)",
			xel = document.createElement('div')

		xel.className   = 'xhr_error'
		xel.textContent = (!window.navigator.onLine) ? ofl : onl
		this.el.insertBefore(xel, this.el.firstChild)
		this.hideStatusBar()
	},

	//	-------------------------------------------------------------------------------------------
	//	Event Handlers -
	//	-------------------------------------------------------------------------------------------
	//
	//	handleTaggingEvent(): Respond to a user input to mark a climber as a favourite (or not)
	//	Behaviour: 
	//	This method relies on click events 'bubbling up' from the relevant view and is 
	//	theoretically a more efficient mechanism than having event handlers within each subview as 
	//	this method requires only a single event handler, where explicit event handlers within each 
	//	subview implies [n] handlers (where 12 < n 80 in our case)
	//
	handleTaggingEvent: function(e){
		var model  = e.target.id,
			status = e.target.checked,
			//	We have to go up 3 levels to 'tag' the list element
			view   = e.target.parentNode.parentNode.parentNode,	
			tagged = null

		// Set the visibility status on the model
		_(this.resultslists).each(function(collection){
			tagged = collection.get(model)
			// If the model was within the collection
			if (tagged) { tagged.set({ 'is_tagged' : status }) }
		})

		// Set the visibility status on the view
		view.classList.toggle('tgd')
		view.classList.toggle('ntg')
	},

	//
	//	handleCategoryChange(): Respond to a user input to change the visible Category.
	//	Behaviour:
	//	If we need to load new data, then call initResultsListView()
	//	If we don't need to load new data, just call animateDOM() to ensure that the view coming 
	//	into focus in sorted 
	//	NOTE: The behaviour of this method is tied to that of initResultsListView(), and depends 
	//	whether we are loading data for both categories at the same time. e.g. For Lead/Boulder we 
	//	load a single category at a time in Qualification but load data for both categories 
	//	simultaneously for the semi-final and final rounds. For Speed we always load only a single 
	//	category at any one time.
	//
	handleCategoryChange: function(){
		//var toggle_loadResults = (!this.currentRound || (this.currentCType === 'S'))
		var loadnewdata = (!this.currentRound || (this.settings.get('comp_type') === 'S'))
		this[(loadnewdata) ? 'initResultsListView' : 'animateDOM']()
	},
})

App.ResultsListView.AnimationModule = {
	// Hard-wire the classes used for animating elements
	_hiddenClass	: 'hidden',
	_containerTag	: 'ul',
	_itemTag		: 'li',
	_filterArray	: [],
	// Define a _margin value as el.offsetHeight does not include any margin
	_margin			: 0,

	//
	//	animateDOM() : animate the ResultsListView elements, passing in an array of classes to 
	//	filter viewable elements
	//
	animateDOM: function(){
		window.console.log('entering animateDOM')
		var containerNodes  = this.el.getElementsByTagName(this._containerTag),
			visibleElements = [],
			containerHeight, h, moveBy

		// Reset the style queue
		this.styleQueue =[]

		// Set the filters in use
		this[this.settings.isFullScreenApp ? '_setDFilters' : '_setMFilters']()

		// Find the elements to be sorted and displayed
		_(containerNodes).each(function(container){
			containerHeight = h = 0

			// Filter and sort the DOM elements (returns an Array of nodes, not a nodelist...)
			visibleElements = this.getVisibleElements(container)

			// Calculate the required translation from the old (el.offsetTop) and required (containerHeight) position
			// of the element. Then push to the style queue and update container height ahead of moving to the next
			// element..
			_(visibleElements).each(function(el){
				// The element height (h) is the same for all els, so define once.
				// TODO: Math.round() forces resizes/translations to whole pixels but not sure if this is necessary?
				h = h || Math.round(el.offsetHeight * (1 + this._margin))
				moveBy = Math.round(containerHeight - el.offsetTop)
				this.styleQueue.push({ el : el, style : this._applyTransform(1, moveBy, 1) })
				containerHeight += h // (el.offsetHeight * (1 + this._margin))
			}, this);

			// Finally, push a style instruction to update the overall height of the container
			this.styleQueue.push({ el: container, style: { height : containerHeight+'px' } })
		}, this)

		// Run through the styleQueue to apply styles to each element in the queue
		_(this.styleQueue).each(function(obj){
			for (var key in obj.style) { obj.el.style[key] = obj.style[key] }
		})

		// Release memory..  visibleElements should be release automatically..
		this.styleQueue = []
	},
	_setMFilters: function(){
		var filter = []
		// Show either Male/Female; or Male+Favourite/Female+Favourite
		filter.push(this.settings.get('ShowCategory') ? 'm_list' : 'f_list')
		if (this.settings.get('ShowFavorites')) { filter.push('tgd') }

		// Set the class filter and element margin for the Mobile Apps
		this._filterArray = filter
		this._margin      = 0
	},
	_setDFilters: function(){
		// If we need to hide one of the results lists (user selected by overloading the ShowFavorites property for
		// this purpose)
		this.toggleViews(this.settings.get('ShowFavorites'))

		// Call bespoke functions to apply filters to animate by page or 'ticker'
		this[(this.currentRound < 2) ? 'pagingAnimation' : 'tickerAnimation']()

		// Set the class filter and element margin for the Desktop Apps
		this._filterArray = ['show']
		this._margin      = 1/12
	},
	//
	//	pagingAnimation(): Set a filter on each element to simulate paging through the results.
	//
	pagingAnimation: function(){
		var order

		// Iterate across each subview, and set its visibility
		_(this.subviews).each(function(view){
			order = view.model.get('display_order');
			view.el.classList[((order > this.swapCounter) && (order <= this.displayCounter)) ? 'add' : 'remove']('show')
		}, this)
		// return the filter class (jQuery format)

		// Update the counters
		this.swapCounter    = (this.displayCounter < this.displayLock) ? this.swapCounter + this.displayQuota : 0
		this.displayCounter = this.swapCounter + this.displayQuota
	},
	//
	//	tickerAnimation(): Display the first [n] competitors and scroll through the remainder one at a time.
	//
	tickerAnimation: function(){
		var counter = this.displayCounter,
			viewArr

		// Loop across all the climbers whose display_order property is less than the displayQuota parameter,
		// i.e. typically the climbers ranked 6 or better, but if climbers are tied then only the first 6 will be
		// shown...
		_(this.subviews).each(function(view){
			view.el.classList[(view.model.get('display_order') <= this.displayQuota) ? 'add' : 'remove']('show')
		}, this)

		// Find the climbers whose rankorder property is 1 greater than the value of the displayCounter variable and
		// show them, then iterate the displayCounter variable (or reset it once we get to the end of the list)
		if (this.displayLock > this.displayQuota){
			viewArr = _(this.subviews).filter(function(view){ return view.model.get('display_order') === this.displayCounter+1 }, this)
			_(viewArr).each(function(view){ view.el.classList.add('show') }, this)
		}

		// Update the counter
		this.displayCounter = (counter < this.displayLock-1) ? counter+1 : this.displayQuota
	},

	//
	//	_applyTransform(): Private helper function called from animateDOM() and getVisibleElements() to set CSS
	//	transformation properties
	//
	_applyTransform: function(opacity, translate, scale){
		var string = 'translate3d(0,'+translate+'px,0) scale3d('+scale+','+scale+','+scale+')',
			obj    = { 'opacity' : opacity, '-webkit-transform' : string, 'transform' : string }
			return obj
	},

	//
	//
	//
	getVisibleElements: function(container){
		// window.console.log('entering getVisibleElements')
		var filterArray    = this._filterArray,
			hiddenSelector = '.'+this._hiddenClass,
			activeSelector = '.'+filterArray.join("."),

			// Static nodelists for filtering
			// !important - hiddenNodes MUST use a static nodelist as we mutate the list
			cntentNodes = container.querySelectorAll(this._itemTag),
			activeNodes = container.querySelectorAll(activeSelector),
			hiddenNodes = container.querySelectorAll(hiddenSelector),

			// utility function to check if a given class is contained in the context el (this)
			truthTest   = function(item){ return this.classList.contains(item) },
			isVisible, isFiltered

		// If no filter is defined, return all elements in the container
		if (!filterArray.length) { return cntentNodes }

		// iterate across all the subviews in the container and 'hide' any that don't contain all of the defined filter
		// classes
		_(cntentNodes).each(function(el){
			isVisible  = !el.classList.contains(this._hiddenClass)
			isFiltered = _(filterArray).every(truthTest, el)
			if ( isVisible && !isFiltered){
				this.styleQueue.push({ el: el, style: this._applyTransform(0, 0, 0.001) })
				el.classList.add(this._hiddenClass)
			}
		}, this)

		// Iterate across all of the INITIALLY hidden subviews in the container and 'unhide' them 
		// if they contain the defined filter classes (we've not yet moved them into position)
		_(hiddenNodes).each(function(el){
 			if (_(filterArray).every(truthTest, el)) { el.classList.remove(this._hiddenClass) }
		}, this)

		// OR TRY // Iterate across the notionally visible views and remove the defined hiddenClass (if it exists)
		// _(activeNodes).each(function(el){ el.classList.remove(this._hiddenClass) }, this)

		// Return an  array containing a sorted list of the nodes containing the defined filter classes
		return this._sortByDataAttribute(activeNodes)
	},

	//
	//	_sortByDataAttribute(): Private helper function called by getVisibleElements() to sort 
	//	elements passed to the function by their data-rank and (if ==) data-load attributes. 
	//	!important - returns an array  not a nodelist
	//	NOTE: Accessing data by el.getAttribute('data-rank') is faster than direct access 
	//	el.dataset.rank, so use this
	//
	_sortByDataAttribute: function(nodelist){
		// window.console.log('_sortByDataAttribute')
		// To sort we need to turn the nodelist into an array
		var	itemArray  = Array.prototype.slice.call(nodelist, 0),
			comparator = function(item1, item2) {
				var	a = parseInt(item1.getAttribute('data-rank'), 10),
					b = parseInt(item2.getAttribute('data-rank'), 10)
				// fall back to original order if data matches
				if (a === b) {
					a = parseInt(item1.getAttribute('data-load'), 10)
					b = parseInt(item2.getAttribute('data-load'), 10)
				}
				return ((a > b) ? 1 : (a < b) ? -1 : 0)
			}
		// Sort the input array using the comparator function
		return itemArray.sort(comparator)
	}
}
_.extend(App.ResultsListView.prototype, App.ResultsListView.AnimationModule)

App.ResultsListView.DragManagerModule = {
	//	-------------------------------------------------------------------------------------------
	//	Drag Management Methods -
	//	-------------------------------------------------------------------------------------------
	//
	//	Add support for pull-to-refresh using the non-library method documented at
	//	http://manzzup.blogspot.co.uk/2014/02/making-html-pull-to-refresh-list-for.html
	//	adapted (a) to conform to the method structure used by the Hammer-1.0.5 example
	//
 	_isTouchEnabled     : Modernizr.touch,
	_isTouched			: false,
	_initialTouchPointY	: null,
	_previousTouchPointY: null,
	_dragLength         : 0,
	_breakPoint			: 144,	// Hard-code the _breakpoint for the Pull-To-Refresh action at 3* the item height

	//
	//	initDragManager(): Add new events to the View (can probably get rid of this if we want to 
	//	optimise later) Adds either touch or mouse events, this could probably be enhanced if we 
	//	want to deal with devices capable of both touch and mouse input
	//
	initDragManager: function(){
		var events = this._isTouchEnabled ?
				['touchstart','touchend','touchleave','touchmove'] : ['mousedown','mouseup','mouseleave','mousemove']

		_(events).each(function(type){ this.events[type] = 'handleDragEvents' }, this)
	},

	//
	//	HandlePullEvents(ev): Deal with a vertical drag and release
	//	Based on a much simplified implementation of the Pull-to-Refresh example at
	//	http://eightmedia.github.io/hammer.js/examples/pull-to-refresh.html but independent of the 
	//	Hammer.js library
	//	No debouncing at the moment (using _.debounce() doesn't appear to be viable for touch 
	//	devices)
	//
	handleDragEvents: function(e){
		switch(e.type) {
		// on start reset the position of the wrapper element
		case 'mousedown':
		case 'touchstart':
			// Find the initial touch point, and record the touch event
			// window.console.log('ontouchstart' in window)
			this._isTouched           = true
			this._initialTouchPointY  = this._isTouchEnabled ? e.changedTouches[0].clientY : e.clientY
			this._previousTouchPointY = this._initialTouchPointY

			// Reset the Status Bar, if not already done so
			this.resetStatusBar()
			break
		// while are dragging down the wrapper element, update the display
		case 'mousemove':
		case 'touchmove':
			// Determine the current touch position and determine the direction of movement (up or down)
			var theTouchPointY = this._isTouchEnabled ? e.changedTouches[0].clientY : e.clientY,
				isDraggedDown  = (theTouchPointY - this._previousTouchPointY) > 0

			if (this._isTouched && isDraggedDown) {
				// If when the drag event is underway the window is scrolled down:
				// (a) where the top row is out of focus, exit without doing anything (i.e. don't 
				// permit a drag);
				if (window.scrollY > 48) { return }
				// (b) if the first cell is only partially visible, reset the scroll position to 
				// snap back and show the full row before continuing
				else if (window.scrollY !== 0) { window.scrollTo(0,0) }

				// Adjust (and store) the drag length and then set the height (position) of the 
				// status bar
				this._dragLength = theTouchPointY - this._initialTouchPointY
				this.setStatusBarHeight(this._dragLength * 0.4)

				// Increment the previousTouchPointY ahead of the next dragdown() call
				this._previousTouchPointY = theTouchPointY

				// Stop the browser from scrolling
				e.preventDefault()
			}
			break
		// If the event wasn't a touch initiation or 'pointer' movement, then it must be a release 
		// (a touchend/mouseup event) or the 'pointer' has moved offscreen (i.e. a touchleave/mouseleave event)
		default:
			// If the screen hasn't been dragged down, then exit (this may be redundant)
			if (this._dragLength === 0) {
				window.console.log('dragLength === 0');
				return }

			// if over the breakpoint when release then use a CSS transform to 'animate' the 
			// snap-back; set the Status bar height (which will be zeroed when the callback is 
			// complete) and trigger the callback
			if (this._dragLength >= this._breakPoint) {
				window.console.log('this._dragLength >= this._breakPoint: '+this._dragLength+', '+this._breakPoint)
				this.el.classList.add('slide-transform')
				this.setStatusBarHeight(24)
				this.onDragRelease()
			}
			// but if not over the breakpoint then just hide the statusbar (this also resets the 
			// pull status) to do this without any animation effect then use resetStatusBar()
			else {
				window.console.log('this._dragLength !>= this._breakPoint: '+this._dragLength+', '+this._breakPoint)
				this.hideStatusBar()
			}
			//
			this._isTouched  = false
			this._dragLength = 0
		}
	},

	//
	//	onDragRelease(): Callback function when we stop dragging, either load new results or update 
	//	the results depending upon the context when called.
	//
	onDragRelease: function(){
		// if we're showing an xhrerror (in which case there will be no subviews as no climbers are 
		// shown);
		// or if the list of climbers on display is a list of starters from registration then call 
		// initResultsListView()
		if (!this.subviews.length || !!this.starters) { this.initResultsListView() }
		// But if there are already 'results' on display then refresh these
		else { this.updateViewContent({ 'force_refresh' : true }) }
	},

	//
	//	hideStatusBar(): Animated closure of the status bar
	//	A bit of a misnomer, as we never actually do anything with the status bar, we're actually 
	//	translating the content of the wrapper element so that the status bar moves offscreen. The 
	//	setTimeout() call delays the reset of all the relevant variables until after the animation 
	//	has completed (as we use a 300ms animation within 'slide-transform')
	//
	hideStatusBar: function(){
		var self = this
		this.el.classList.add('slide-transform')
		this.setStatusBarHeight(0)
		// Postpone the reset until after the transform completes (300ms)
		setTimeout(function() { self.resetStatusBar() }, 400)
	},

	//
	//	resetStatusBar(): Reset the pull status - remove any CSS transform, reset the 
	//	_slidedown_height and _dragged_down parameters and the move the wrapper element back to Y=0
	//
	resetStatusBar: function(){
		this.setStatusBarHeight(0)
		this.el.classList.remove('slide-transform')
	},

	//
	//	setStatusBarHeight(height): A simple utility function to translate the wrapper element by 
	//	the specified amount
	//
	setStatusBarHeight: function(height){
		this.el.style.transform       = 'translate3d(0,'+height+'px,0)';
		this.el.style.webkitTransform = 'translate3d(0,'+height+'px,0)';
	}
}
_.extend(App.ResultsListView.prototype, App.ResultsListView.DragManagerModule)


//	MVC style coding for a dynamic presentation of competition results
//	Copyright 2012-14  T J Hatch
//
//	Licensed under the Apache License, Version 2.0 (the "License");
//	you may not use this file except in compliance with the License.
//	You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
//	Unless required by applicable law or agreed to in writing, software
//	distributed under the License is distributed on an "AS IS" BASIS,
//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//	See the License for the specific language governing permissions and
//	limitations under the License.

//	-----------------------------------------------------
//	CODEKIT DECLARATIONS
//	-----------------------------------------------------
/* global _        */
/* global App      */
//	-----------------------------------------------------
//	SCOPE DECLARATIONS
//	-----------------------------------------------------
var App = App || {}

//	-----------------------------------------------------
//	BClimberView...
//	-----------------------------------------------------
//
//	Extend (subclass) the base ClimberView class with methods specific for Boulder Competitions
//
App.BClimberView = App.ClimberView.extend({
	//
	//	Override the default render() function
	//
	render: function(){
		// Render the underscore template
		var tmpl  = document.getElementById('bclimber_template').textContent,
			str

		str = _.template(tmpl, {
			rank	: this.model.get('rank_prev_heat'),
			name	: this.model.get('lastname'),
			code	: this.model.get('nation'),
			per_id	: this.model.get('per_id')
		})

		// Render the view skeleton and append the results-containing elements into the DOM
		this.el.innerHTML = str
		this.appendResultsNodes()

		// Cache references to the DOM elements that will be updated for this view to avoid having to traverse the DOM
		// each time .update() is called
		this.rk_el = this.el.getElementsByClassName('brnk')[0]
		this.tp_el = this.el.getElementsByClassName('tp')
		this.bn_el = this.el.getElementsByClassName('bn')
		this.TA_el = this.el.getElementsByClassName('TA')[0]

		// Enable chaining
		return this
	},

	//
	//	Override the default appendResultsNodes() function
	//
	appendResultsNodes: function(){
		var frag = document.createDocumentFragment(),
			r    = this.model.collection.round,			// Non zero if semifinal or final
			c    = (this.model.collection.cat > 10),	// True if a Youth competition
			n, t, b

		// Figure out how many results cells we need, 8, 5 or 4
		if (r < 2) { n = c ? 8 : 5 } else { n = 4 }

		// Append [n] 'top' display elements and [n] 'bonus' display elements. We use CSS3:Flexbox and CSS:Box-Sizing
		// to define the relative position of the elements
		while (n) {
			t = document.createElement('span')
			b = document.createElement('span')
			t.textContent = 'x'
			t.className = 'tp'
			b.className = 'bn'
			frag.appendChild(t)
			frag.appendChild(b)
			n--
		}
		this.el.getElementsByClassName('result_bloc')[0].appendChild(frag)
	},

	//
	//	Override the default update() function
	//
	update: function(){
		var t = [], b = [], ta = 0

		// Update the displayed rank & the data-rankorder property used by the ResultsListView::animateDOM sort
		this.rk_el.textContent = this.model.get('result') ? this.model.get('calculated_rank') : ''
		this.el.setAttribute('data-rank', this.model.get('display_order') || this.model.get('start_order'))

		// Iterate across the bonus indicator cells & set the css based the relevant attempt value
		_(this.bn_el).each(function(el, i){
			b.push(this.parseResults("b", i))
			el.classList[(b[i] > 0) ? 'add' : 'remove']('GLight')
		}, this)

		// Iterate across the top indicator cells & set the css based the relevant attempt value
		_(this.tp_el).each(function(el, i){
			t.push(this.parseResults("t", i))
			el.classList[(t[i] > 0) ? 'add' : 'remove']('GLight')
			el.style.color = (b[i] === 0 || (!!b[i] && !t[i])) ? 'rgba(255,0,0,1)' : 'rgba(255,0,0,0)'
		}, this)

		// Calculate and display the number of attempts
		_(t).each(function(x){ ta += x })
		// Optional test to display the number of attempts to bonus where the climber has no tops..
		// if (ta === 0) _(b).each(function(x){ ta += x })
		this.TA_el.innerHTML = ta || '&nbsp;'
	},

	//
	// Override the default parseResults() function to return the number of attempts only
	//
	parseResults: function(type, i){
		var rs  = this.model.get('rArr'),
			str = type+"[0-9]{1,}",
			val = rs[i] ? rs[i].match(str) : null

		return val ? parseInt(val[0].slice(1), 10) : null
	}
});


//	MVC style coding for a dynamic presentation of competition results
//	Copyright 2012-14  T J Hatch
//
//	Licensed under the Apache License, Version 2.0 (the "License");
//	you may not use this file except in compliance with the License.
//	You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
//	Unless required by applicable law or agreed to in writing, software
//	distributed under the License is distributed on an "AS IS" BASIS,
//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//	See the License for the specific language governing permissions and
//	limitations under the License.

//	-----------------------------------------------------
//	CODEKIT DECLARATIONS
//	-----------------------------------------------------
/* global _        */
/* global App      */
//	-----------------------------------------------------
//	SCOPE DECLARATIONS
//	-----------------------------------------------------
App.FullScreenMixins = {}

//	-----------------------------------------------------
//	ApplicationObject
//	-----------------------------------------------------

App.FullScreenMixins.AppObject = {
//
//  scaleToScreen(): Sets the base font size for the document based on the reported screen height and width
//	Calculates the scaling factor as a % (rounded down to the nearest integer) of either the screen width or height
//	Use the minimum factor from height/width so as to fit the screen independent of its aspect ratio
//
    scaleToScreen: function(){
        var w = screen.width/724,
			h = screen.height/448,
			s = Math.min(w,h),
			x = 5*Math.floor(20 * s) // ; window.console.log(x+'%')

		document.documentElement.style.fontSize = x + '%'
//		document.documentElement.style.fontSize = Math.floor(100 * s) + '%'
	}
}

//	-----------------------------------------------------
//	ResultsList
//	-----------------------------------------------------

App.FullScreenMixins.ResultsList = {
	//
	//	setDisplayValues(): override the setDisplayValues() function of the base (mobile) app.
    //  Specifically, we need to force a stable display order because of the 'paging' display (this is not needed in the
    //  mobile app as all results are technically on display, though not necessarily visible in the viewport). If the
	//	display order is not stable, then results may be 'missed' or displayed twice (once pre-page and again post-page)
	//
	setDisplayValues: function(){
		var a = this.models,
			l = this.length,
			i, j, cr

		// Iterate across the models setting rank and display ordering parameters
		for (i = 0, j = 1, a[0].set({ 'calculated_rank' : 1, 'display_order' : 1 }); j < l; i++, j++) {
			cr = (a[i].get('sort_value') === a[j].get('sort_value')) ? a[i].get('calculated_rank') : (j+1)
			a[j].set({ 'calculated_rank' : cr , 'display_order' : j+1 })
		}

		// Call setDisplayTime() to show time in (only for the Lead Final)
		if (this.LF) this.setDisplayTime()
	}
}

//	-----------------------------------------------------
//	ResultsListView
//	-----------------------------------------------------

App.FullScreenMixins.ResultsListView = {
	//
	//	autoRefresh(): Use an interval timer to fetch data from the server every 10s or 30s
	//
	autoRefresh: function(){
		var self     = this,
			lArr     = _(this.resultslists).pluck('length'),
			interval = this.currentRound ? 5000 : 30000

		// Clear any exising interval from memory
		if (this.intervalTimer) { clearInterval(self.intervalTimer) }

		// window.console.log(interval)
		// Reset the swapCounter, displayCounter and displayLock parameters
		this.swapCounter    = 0
		this.displayCounter = this.displayQuota = this.currentRound ? 6 : 7
		this.displayLock    = _(lArr).max()

		// First we re-fire animateDOM(), as the desktop app calls swapView or swapPage from animateDOM() and these
		// functions each require this.displayLock, this.displayCounter and this.swapCounter to have been defined,
		// which is in this function. So any earlier call on animateDOM() will not correctly define the view filters
		this.animateDOM()

		// Set up the interval timer
		this.intervalTimer = setInterval(function(){
			self.updateViewContent({ force_refresh : 'true' })
		}, interval)
	},

	//
	//	toggleViews(bool): On the Desktop application, we override the behaviour of the 'favorites' button in the Header
	//	bar, so that instead of toggling the view state of an individual climber, it centers the left-hand ul element
	//	and hides the right-hand ul elements
	//
	toggleViews: function(bool){
		var ul1    = this.el.getElementsByTagName('ul')[0],
			ul2    = this.el.getElementsByTagName('ul')[1],
			action = bool ? 'add' : 'remove'

		ul1.classList[action]('shift')
		ul2.classList[action]('hide')
	}
}

//
//	Extend the relevant objects
//
_.extend(window.applicationObject, App.FullScreenMixins.AppObject)
_.extend(App.ResultsList.prototype, App.FullScreenMixins.ResultsList)
_.extend(App.ResultsListView.prototype, App.FullScreenMixins.ResultsListView)

//	MVC style coding for a dynamic presentation of competition results
//	Copyright 2012-14  T J Hatch
//
//	Licensed under the Apache License, Version 2.0 (the "License");
//	you may not use this file except in compliance with the License.
//	You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
//	Unless required by applicable law or agreed to in writing, software
//	distributed under the License is distributed on an "AS IS" BASIS,
//	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//	See the License for the specific language governing permissions and
//	limitations under the License.

//	-----------------------------------------------------
//	CODEKIT DECLARATIONS
//	-----------------------------------------------------
/* global _        */
/* global Backbone */

// Module: Underscore extensions
// @codekit-prepend "../../core/js/THArray.js"

// Module: Application code
// @codekit-prepend "../../core/js/THSettings.js"
// @codekit-prepend "../../core/js/THHeader.js"
// @codekit-prepend "../../core/js/THApp.js"

// Module: 'Core Code' for Boulder Results display
// @codekit-prepend "../../core/js/THClimber.js"
// @codekit-prepend "../../core/js/THResultsList.js"

// Module: 'Application' and 'Core-Code' functions specific to auto-updating, 2-pane apps
// @codekit-prepend "./THDBoulderMixins.js"
// @codekit-prepend "./THDAppMixins.js"

//
//	Initialise the object once the DOM has fully loaded
//
document.addEventListener('DOMContentLoaded', function(){
	var idx  = 10,
		cmps = { "wet_id" : 99, "type" : "B", "name" : "Test Competition" },
		defs = { "disciplines" : ['B'], "cat_id" : [5] },
		opts = { "defaultCompetition" :  cmps, "requestParameters" : defs, "isFullScreenApp" : true }

	// Extend Backbone Events to the applicationObject and then initialize the object
	_.extend(window.applicationObject, Backbone.Events)
	window.applicationObject.init(idx,opts)
});


